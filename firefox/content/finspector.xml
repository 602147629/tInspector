<?xml version="1.0"?>

<bindings xmlns="http://www.mozilla.org/xbl" xmlns:html="http://www.w3.org/1999/xhtml">

	<binding id="flash">
		<implementation>
			<constructor>
        <![CDATA[
var current = this;
var parent = current.parentNode;
        
//From Jesse's XPCNativeWrapper: http://mavra.perilith.com/~luser/content/native.js
function nativeMethod(untrustedObject, methodName)
{
  // happier stack traces and faster multiple calls
  var fun = Components.lookupMethod(untrustedObject, methodName);
  
  return function()
  {
    return fun.apply(untrustedObject, arguments);
  }
}

function getElementPosition(element)
{
    // Restrict rectangle coordinates by the boundaries of a window's client area
    function intersectRect(rect, wnd)
    {
      // Cannot use wnd.innerWidth/Height because they won't account for scrollbars
      let doc = wnd.document;
      let wndWidth = doc.documentElement.clientWidth;
      let wndHeight = doc.documentElement.clientHeight;
      if (doc.compatMode == "BackCompat") // clientHeight will be bogus in quirks mode
        wndHeight = Math.max(doc.documentElement.offsetHeight, doc.body.offsetHeight) - wnd.scrollMaxY - 1;
  
      rect.left = Math.max(rect.left, 0);
      rect.top = Math.max(rect.top, 0);
      rect.right = Math.min(rect.right, wndWidth);
      rect.bottom = Math.min(rect.bottom, wndHeight);
    }

    let rect = element.getBoundingClientRect();
    let wnd = element.ownerDocument.defaultView;

    let style = wnd.getComputedStyle(element, null);
    let offsets = [
      parseFloat(style.borderLeftWidth) + parseFloat(style.paddingLeft),
      parseFloat(style.borderTopWidth) + parseFloat(style.paddingTop),
      parseFloat(style.borderRightWidth) + parseFloat(style.paddingRight),
      parseFloat(style.borderBottomWidth) + parseFloat(style.paddingBottom)
    ];

    rect = {left: rect.left + offsets[0], top: rect.top + offsets[1],
            right: rect.right - offsets[2], bottom: rect.bottom - offsets[3]};
    while (true)
    {
      intersectRect(rect, wnd);

      if (!wnd.frameElement)
        break;

      // Recalculate coordinates to be relative to frame's parent window
      let frameElement = wnd.frameElement;
      wnd = frameElement.ownerDocument.defaultView;

      let frameRect = frameElement.getBoundingClientRect();
      let frameStyle = wnd.getComputedStyle(frameElement, null);
      let relLeft = frameRect.left + parseFloat(frameStyle.borderLeftWidth) + parseFloat(frameStyle.paddingLeft);
      let relTop = frameRect.top + parseFloat(frameStyle.borderTopWidth) + parseFloat(frameStyle.paddingTop);

      rect.left += relLeft;
      rect.right += relLeft;
      rect.top += relTop;
      rect.bottom += relTop;
    }

    return rect;
}

var createElement = nativeMethod(document, "createElementNS");

//新建一个按钮,附在swf元素上
function createTriggerBtn(isStandalone) {
	// Create btn
	var btn = createElement("http://www.w3.org/1999/xhtml", "div");
	btn.isStandalone = isStandalone;
	
	//设置背景图
	var image = "url(chrome://finspector/skin/finspector_16.png)";
	btn.style.setProperty("background", image, "important");
	
	//设置位置,长宽
	btn.style.setProperty("min-width", "32px", "important");
	btn.style.setProperty("min-height", "32px", "important");
	
    let objRect = getElementPosition(current);

    let left = objRect.right - btn.offsetWidth;
    let top = objRect.top - btn.offsetHeight;
    if (top < 0)
    {
      top = objRect.bottom;
    }

    if (btn.style.left != left + "px")
      btn.style.setProperty("left", left + "px", "important");
    if (btn.style.top != top + "px")
      btn.style.setProperty("top", top + "px", "important");
	
	parent.insertBefore(btn, current);
}

//document.QueryInterface(Components.interfaces.nsIDOMDocument);

		var swf = current;
		if (!swf.id) {
			swf.id = "fInspectorSwf_" + (new Date()).getTime();
		}
		if (!swf.src
				|| swf.src != 'chrome://finspector/content/tInspectorConsoleMonitor.swf') {
			if (swf.tagName.toUpperCase() == 'OBJECT') {
				// 判断是不是有<param name="allowScriptAccess" value="always" /> 和
				// <param name="allowFullScreen" value="true" />
				
				alert(swf.tagName);
				var childs = swf.childNodes;
				var needAppendScriptAccess = true;
				var needAppendFullScreen = true;
				for ( var i = 0; i < childs.length; i++) {
					var param = childs[i];
					if (param.name.toUpperCase() == "ALLOWSCRIPTACCESS") {
						swf.appendChild(param);
						param.value = "always";
						needAppendScriptAccess = false;
					}
					if (param.name.toUpperCase() == "ALLOWFULLSCREEN") {
						param.value = "true";
						needAppendFullScreen = false;
					}
				}

				if (needAppendFullScreen) {
					param = createElement("http://www.w3.org/1999/xhtml", "param");
					param.name = "allowFullScreen";
					param.value = "true";
					swf.appendChild(param);
				}
				if (needAppendScriptAccess) {
					param = createElement("http://www.w3.org/1999/xhtml", "param");
					param.name = "allowScriptAccess";
					param.value = "always";
					swf.appendChild(param);
				}

			} else if (swf.tagName.toUpperCase() == 'EMBED') {
				swf.setAttribute("allowscriptaccess", "always");
				swf.setAttribute("allowfullscreen", "true");
			}
		}

if(current.src && current.src.indexOf('chrome://') == 0){
}else{
	createTriggerBtn(false);
}
        ]]>
			</constructor>
		</implementation>
	</binding>
</bindings>
